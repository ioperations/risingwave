# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: explain (distsql, trace, verbose) select 1;
  explain_output: |
    Begin:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }

    Share Source:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }

    Predicate Push Down:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }

    Predicate Push Down:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }

    Predicate Push Down:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }

    Prune Columns:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }

    Predicate Push Down:

    LogicalProject { exprs: [1:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }

    To Batch Physical Plan:

    BatchProject { exprs: [1:Int32] }
    └─BatchValues { rows: [[]] }

    To Batch Local Plan:

    BatchProject { exprs: [1:Int32] }
    └─BatchValues { rows: [[]] }

    {
      "root_stage_id": 0,
      "stages": {
        "0": {
          "root": {
            "plan_node_id": 28,
            "plan_node_type": "BatchProject",
            "schema": [
              {
                "dataType": {
                  "typeName": "INT32",
                  "isNullable": true
                },
                "name": "1:Int32"
              }
            ],
            "children": [
              {
                "plan_node_id": 26,
                "plan_node_type": "BatchValues",
                "schema": [],
                "children": [],
                "source_stage_id": null
              }
            ],
            "source_stage_id": null
          },
          "parallelism": 1,
          "exchange_info": {
            "mode": "SINGLE"
          }
        }
      },
      "child_edges": {
        "0": []
      },
      "parent_edges": {
        "0": []
      }
    }
- sql: |
    create table t1(v1 int);
    create table t2(v2 int);
    explain (logical) select * from t1 join t2 on v1=v2;
  explain_output: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
    ├─LogicalScan { table: t1, columns: [v1] }
    └─LogicalScan { table: t2, columns: [v2] }
- sql: |
    create table t1(v1 int);
    create table t2(v2 int);
    explain (logical, trace) select * from t1 join t2 on v1=v2;
  explain_output: |+
    Begin:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Share Source:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Predicate Push Down:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Predicate Push Down:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Predicate Push Down:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Push Down the Calculation of Inputs of Join's Condition:

    apply PushCalculationOfJoinRule 1 time(s)

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1, _row_id] }
      └─LogicalScan { table: t2, columns: [v2, _row_id] }

    Prune Columns:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1] }
      └─LogicalScan { table: t2, columns: [v2] }

    Predicate Push Down:

    LogicalProject { exprs: [t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
      ├─LogicalScan { table: t1, columns: [v1] }
      └─LogicalScan { table: t2, columns: [v2] }

    Project Remove:

    apply ProjectEliminateRule 1 time(s)

    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2) }
    ├─LogicalScan { table: t1, columns: [v1] }
    └─LogicalScan { table: t2, columns: [v2] }

- sql: |
    explain (logical) create table t1(v1 int);
  explain_output: |
    LogicalSource
